## End-state targets (so each iteration snaps into place)

* **Single repo, modular**: `client/`, `server/`, `infra/terraform/`, `.github/workflows/`
* **AWS-first production shape** (minimal moving parts):

  * **CloudFront + S3**: frontend
  * **ECS Fargate**: backend API (single service initially)
  * **RDS Postgres**: primary DB (multi-tenant with `company_id`)
  * **Cognito (OIDC)**: OAuth login (roles live in DB)
  * **S3**: documents/attachments (later)
  * **SSM/Secrets Manager**: secrets
  * **CloudWatch logs/alarms**: baseline
* **GitHub Actions** deploys everything:

  * Terraform plan/apply per environment
  * Build & push API image to ECR
  * Build & upload SPA to S3, invalidate CloudFront

You will iterate by adding modules/features to the **single API** first (modular code), and only split into more services when forced by scale.

---

# Iteration plan (small slices)

## Slice 0 — Repository + standards (1–2 hours)

**Goal:** repo is ready for clean iterations.

### Deliverables

* Monorepo structure:

  * `client/` (React/Vite)
  * `server/` (Node/TypeScript API)
  * `shared/` (types, zod schemas, constants)
  * `infra/terraform/` (modules + envs)
  * `.github/workflows/` (pipelines)
* Conventions:

  * API routes under `/api`
  * Every DB table has `company_id` (except platform admin tables)
  * RBAC enforced server-side (never trust frontend)

### Acceptance criteria

* `npm run dev` runs locally (client+server)
* `npm run test` exists (even if minimal)

---

## Slice 1 — “Platform skeleton” deployed (frontend + backend with health endpoints)

**Goal:** real AWS deployment works end-to-end with no app logic.

### AWS components (minimum)

* Route53 + ACM cert (optional early; can use default domain at first)
* VPC (public + private subnets)
* ALB for API
* ECS cluster + Fargate service (API)
* ECR repo (API image)
* S3 bucket for SPA + CloudFront distribution
* CloudWatch log groups

### API endpoints

* `GET /api/health` → `{status:"ok"}`
* `GET /api/version` → git SHA/build id

### Acceptance criteria

* Visiting CloudFront URL loads UI (even if placeholder)
* UI calls `/api/health` successfully

---

## Slice 2 — Auth (OAuth) + roles + multi-tenant core tables

**Goal:** login works; user belongs to a company; roles exist.

### Auth approach (keep it future-proof)

* Use **Cognito User Pool** for OAuth/OIDC
* Backend validates **JWT access token** (issuer + audience + JWKS)
* Map Cognito `sub` → internal `users` table
* Roles/memberships stored in DB:

  * `companies`
  * `users`
  * `company_users` (role)
  * optional `invites` (later)

### Roles you support now (DB enum)

* `PLATFORM_ADMIN`
* `COMPANY_OWNER`
* `PROPERTY_MANAGER`
* `MAINTENANCE`
* `TENANT`

### Minimum UI

* “Log in” button
* After login show:

  * current company name
  * your role(s)
  * logout

### Acceptance criteria

* Unauthed user gets 401 on `/api/me`
* Authed user gets `/api/me` with company + role
* Tenant isolation framework exists (middleware)

---

## Slice 3 — First real feature: Properties + Units CRUD (scoped)

**Goal:** first vertical slice of business value.

### Tables

* `properties(company_id, …)`
* `units(company_id, property_id, …)`

### API

* `POST /api/properties`
* `GET /api/properties`
* `POST /api/properties/:id/units`
* `GET /api/properties/:id/units`

### RBAC rules

* Owners/Managers can CRUD
* Tenants can only read their assigned unit later (not yet)

### Acceptance criteria

* Staff cannot access other companies’ properties even by ID guessing
* E2E test: create property → list → create unit → list

---

## Slice 4 — Tenants + Leases (minimal)

**Goal:** occupancy + who lives where.

### Tables

* `tenants(company_id, …)`
* `leases(company_id, unit_id, start_date, end_date, status, …)`
* `lease_tenants(company_id, lease_id, tenant_id)`

### Acceptance criteria

* Unit shows “occupied” if active lease exists
* Tenant portal can view lease summary (read-only)

---

## Slice 5 — Rent charges (no processor) + ledger skeleton

**Goal:** real accounting spine without payments.

### Tables

* `charges(company_id, lease_id, amount, due_date, status)`
* `ledger_entries(company_id, ref_type, ref_id, amount, occurred_at)`

### Job

* Monthly rent generation (EventBridge Scheduler → ECS task or API endpoint called by scheduler)

### Acceptance criteria

* Charge auto-created for active leases on schedule
* Tenant sees balance (sum unpaid charges)

---

## Slice 6 — Maintenance requests + work orders

**Goal:** tenant → staff workflow.

### Tables

* `maintenance_requests(company_id, unit_id, tenant_id, status, …)`
* `work_orders(company_id, request_id, assigned_to_user_id, status, …)`

### Acceptance criteria

* Tenant submits request
* Staff assigns and updates status
* Activity log exists (even simple)

---

# Architecture blueprint (what you build once)

## Environments

* `dev` (cheap, fast)
* `prod` (later)

Naming:

* `propertyflow-dev-*`
* `propertyflow-prod-*`

## Network

* VPC with:

  * Public subnets: ALB, NAT (if needed)
  * Private subnets: ECS tasks, RDS
* Security groups:

  * ALB ingress 443
  * ECS ingress from ALB
  * RDS ingress from ECS only

## Data

* RDS Postgres (dev: smallest instance)
* Migrations run in pipeline (or one-off task)

## Secrets/config

* Secrets Manager:

  * DB password
  * JWT config if needed
* SSM Parameter Store:

  * non-sensitive env values

## Observability (baseline)

* CloudWatch logs for ECS
* ALB access logs (optional)
* CloudWatch alarms:

  * 5xx on ALB
  * ECS task restarts
  * RDS CPU/storage thresholds

---

# Terraform layout (detailed)

## Recommended repo structure

```
infra/terraform/
  modules/
    network/
    ecs_api/
    rds_postgres/
    cognito/
    s3_frontend/
    cloudfront/
    iam/
    observability/
  envs/
    dev/
      main.tf
      variables.tf
      terraform.tfvars
      backend.tf
    prod/
      main.tf
      variables.tf
      terraform.tfvars
      backend.tf
```

## State backend

* S3 remote state + DynamoDB lock

  * `propertyflow-tfstate`
  * `propertyflow-tflock`

## Terraform workflow rules

* PRs: `terraform fmt` + `terraform validate` + `terraform plan` (comment output)
* Main branch: apply to **dev**
* Tagged release (`v*`): apply to **prod**

---

# GitHub Actions (detailed pipelines)

## 1) `ci.yml` (on PR)

* Lint + tests (client/server)
* Build server docker image (no push)
* Terraform format/validate
* Terraform plan for dev (no apply)
* Upload plan artifact

## 2) `deploy-dev.yml` (on merge to main)

Order:

1. Terraform apply (dev)
2. Build & push API image to ECR
3. Update ECS service to new image (force deployment)
4. Build SPA → upload to S3
5. CloudFront invalidation

## 3) `deploy-prod.yml` (on tag vX.Y.Z)

Same as dev but against prod env, with manual approval gate.

### Required GitHub secrets

* `AWS_ROLE_TO_ASSUME` (OIDC role arn)
* `AWS_REGION`
* (Optional) `TF_STATE_BUCKET` etc.

### Use GitHub OIDC (no long-lived AWS keys)

* Create an IAM role trusted by GitHub Actions
* Grant it least-privilege for:

  * Terraform resources
  * ECR push
  * ECS update
  * S3 upload + CloudFront invalidation

---

# Application code structure (so iteration is easy)

## Server modules

* `server/src/auth/` (JWT validation + req.user)
* `server/src/rbac/` (role checks)
* `server/src/tenant/` (company resolution middleware)
* `server/src/db/` (ORM + migrations)
* `server/src/modules/`

  * `companies/`
  * `properties/`
  * `leases/`
  * `billing/`
  * `maintenance/`

## Tenant isolation rule

Every request gets:

* `req.userId`
* `req.companyId`
  All queries require `companyId`.

## Permissions model

* `company_users.role` drives access
* Optional granular permissions later (`permissions` table)

---

# What you do first (exact build order)

## Week 1: deploy skeleton

1. Create Terraform state backend (S3 + DynamoDB)
2. Build `dev` environment: VPC + ECS + ALB + S3 + CloudFront
3. Deploy placeholder UI + `/api/health`

## Week 2: auth + tenancy

1. Add Cognito module + app client
2. Implement JWT validation middleware in API
3. Add DB tables: users/companies/company_users
4. Implement `/api/me`
5. Minimal UI showing login state

## Week 3: properties/units vertical slice

1. CRUD APIs + UI screens
2. Enforce RBAC + tenant scoping
3. Add integration test(s)

---

# Definition of Done per slice (enforced)

Each slice must include:

* Terraform updated (if infra changed)
* GitHub Actions passes
* Smoke test endpoint exists
* Basic audit log entry for critical actions (even simple table)
* Rollback method documented (redeploy previous image/tag)

---

If you want, paste the tech choices you want for **client framework** (React/Vite vs Next), **server framework** (Express vs Fastify), and **ORM** (Prisma vs Drizzle). If you don’t care, the default that fits this plan cleanly is: **React + Vite**, **Fastify**, **Prisma + Postgres**.
